\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{GOST}

\usepackage{graphicx}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{float}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

% Для листинга кода:
\lstset{ %
	language=c++,                 % выбор языка для подсветки
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=7pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=4,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\#*}{*)},   % если нужно добавить комментарии в коде
}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}


\begin{document}
	%\def\chaptername{} % убирает "Глава"
\begin{titlepage}
	\begin{table}[ht]
		\centering
		\begin{tabular}{|c|p{400pt}|} 
			\hline
			\begin{tabular}[c]{@{}c@{}} \includegraphics[scale=1]{pics/b_logo.jpg} \\\end{tabular} &
			\footnotesize\begin{tabular}[c]{@{}c@{}}\textbf{Министерство~науки~и~высшего~образования~Российской~Федерации}\\\textbf{Федеральное~государственное~бюджетное~образовательное~учреждение}\\\textbf{~высшего~образования}\\\textbf{«Московский~государственный~технический~университет}\\\textbf{имени~Н.Э.~Баумана}\\\textbf{(национальный~исследовательский~университет)»}\\\textbf{(МГТУ~им.~Н.Э.~Баумана)}\\\end{tabular}  \\
			\hline
		\end{tabular}
	\end{table}
\noindent\rule{\textwidth}{4pt}
\noindent\rule[14pt]{\textwidth}{1pt}
\hfill 
\noindent
\makebox{ФАКУЛЬТЕТ~}%
\makebox[\textwidth][l]{\underline{~«Информатика и системы управления»~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}%
\\
\noindent
\makebox{КАФЕДРА~}%
\makebox[\textwidth][l]{\underline{~«Программное обеспечение ЭВМ и информационные технологии»~}}%
\\

\begin{center}
	\vspace{1.5cm}
	{\bf\huge Отчёт\par}
	{\bf\Large по лабораторной работе № 6\par}
	\vspace{0.7cm}
\end{center}


\noindent
\makebox{\large{\bf Название:}~~~}
\makebox[\textwidth][l]{\large\underline{~Муравьиный алгоритм~~~~~~~~~~~~~}}\\

\noindent
\makebox{\large{\bf Дисциплина:}~~~}
\makebox[\textwidth][l]{\large\underline{~Анализ алгоритмов~~~~~~~~~~~~~~~~~~~~~~~~~~}}\\

\vspace{1.5cm}
\noindent
\begin{tabular}{l c c c c c}
	Студент      & ~ИУ7-54Б~               & \hspace{3.5cm} & \hspace{2cm}                 & &  Д.Ю. Расколотов \\\cline{2-2}\cline{4-4} \cline{6-6} 
	\hspace{3cm} & {\footnotesize(Группа)} &                & {\footnotesize(Подпись, дата)} & & {\footnotesize(И.О. Фамилия)}
\end{tabular}

\noindent
\begin{tabular}{l c c c c}
	Преподователь & \hspace{6cm}   & \hspace{2cm}                 & & Л.Л. Волкова\\\cline{3-3} \cline{5-5} 
	\hspace{3cm}  &                & {\footnotesize(Подпись, дата)} & & {\footnotesize(И.О. Фамилия)}
\end{tabular}

\vspace{0.6cm}
\begin{center}	
	\vfill
	\large \textit {Москва, 2020}
\end{center}

\thispagestyle {empty}
\pagebreak
\end{titlepage}

\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
Муравьиный алгоритм — один из эффективных полиномиальных алгоритмов для нахождения приближённых решений задачи коммивояжёра, а также решения аналогичных задач поиска маршрутов на графах.

Целью данной лабораторной работы является изучение муравьиных алгоритмов и приобретение навыков параметризации методов на примере муравьиного алгоритма, примененного к задаче коммивояжера.

Задачи данной лабораторной работы:
\begin{itemize}
	\item рассмотренть муравьиный алгоритм и алгоритм полного перебора в задаче коммивояжера;
	\item реализовать эти алгоритмы;
	\item сравнить время работы этих алгоритмов.
\end{itemize}



\chapter{Аналитическая часть}
В данной части будут рассмотрены теоретические основы задачи коммивояжера и муравьиного алгоритма. 

\section{Постановка задачи} 
Имеется сильно связный взвешенный ориентированный граф с положительными весами, заданный в виде матрицы смежностей. Количество вершин в нем лежит в диапазоне от 5 до 20.Требуется решить задачу коммивояжера для этого графа\cite{diskr}. 

\section{Задача коммивояжера}
Коммивояжёр — бродячий торговец. Задача коммивояжёра — важная задача транспортной логистики, отрасли, занимающейся планированием транспортных перевозок. Коммивояжёру, чтобы распродать нужные и не очень нужные в хозяйстве товары, следует объехать n пунктов и в конце концов вернуться в исходный пункт. Требуется определить наиболее выгодный маршрут объезда. В качестве меры выгодности маршрута (точнее говоря, невыгодности) может служить суммарное время в пути, суммарная стоимость дороги, или, в простейшем случае, длина маршрута \cite{commi2}.

\section{Решение полным перебором}
Задача может быть решена перебором всех вариантов объезда и выбором оптимального. Но при таком подходе количество возможных маршрутов очень быстро возрастает с ростом n (оно равно n! — количеству способов упорядочения пунктов).

\section{Муравьиные алгоритмы}
Все муравьиные алгоритмы базируются на моделировании поведения колонии муравьев. Колония муравьев может рассматриваться как система, в которой каждый муравей функционирует автономно по очень простым правилам. В противовес почти примитивному поведению муравьёв, поведение всей системы получается на удивление разумным.

Муравьиные алгоритмы представляют собой вероятностную жадную эвристику, где вероятности устанавливаются, исходя из информации о качестве решения, полученной из предыдущих решений.

Идея муравьиного алгоритма - моделирование поведения муравьёв, связанного с их способностью быстро находить кратчайший путь от муравейника к источнику пищи и адаптироваться к изменяющимся условиям, находя новый кратчайший путь. При своём движении муравей метит путь феромоном, и эта информация используется другими муравьями для выбора пути. Это элементарное правило поведения и определяет способность муравьёв находить новый путь, если старый оказывается недоступным.

Рассмотрим случай, когда на оптимальном доселе пути возникает преграда. В этом случае необходимо определение нового оптимального пути. Дойдя до преграды, муравьи с равной вероятностью будут обходить её справа и слева. То же самое будет происходить и на обратной стороне преграды. Однако, те муравьи, которые случайно выберут кратчайший путь, будут быстрее его проходить, и за несколько передвижений он будет более обогащён феромоном. Поскольку движение муравьёв определяется концентрацией феромона, то следующие будут предпочитать именно этот путь, продолжая обогащать его феромоном до тех пор, пока этот путь по какой-либо причине не станет недоступен.

Очевидная положительная обратная связь быстро приведёт к тому, что кратчайший путь станет единственным маршрутом движения большинства муравьёв. Моделирование испарения феромона - отрицательной обратной связи - гарантирует нам, что найденное локально оптимальное решение не будет единственным - муравьи будут искать и другие пути. Если мы моделируем процесс такого поведения на некотором графе, рёбра которого представляют собой возможные пути перемещения муравьёв, в течение определённого времени, то наиболее обогащённый феромоном путь по рёбрам этого графа и будет являться решением задачи, полученным с помощью муравьиного алгоритма.


Теперь рассмотрим шаги для реализации этого алгоритма:\\

1. Создание муравьев\\
Стартовая точка, куда помещается муравей, зависит ограничений,   накладываемых условиями задачи. Потому что для каждой задачи   способ размещения муравьёв является определяющим. Либо все    они помещаются в одну точку, либо в разные с повторения, либо    без повторений. \\
На этом же этапе задается начальный уровень феромона. Он    инициализируется небольшим положительным числом для того,    чтобы на начальном шаге вероятности перехода в следующую    вершину не были нулевыми. \\

2. Поиск решения  \\
Вероятность перехода из вершины i в вершину j определяется по следующей формуле\ref{form:way}\\   
\begin{equation}\label{form:way} 
	p_{i,j}={\frac {(\tau _{i,j}^{\alpha })(\eta _{i,j}^{\beta })}{\sum (\tau _{i,j}^{\alpha })(\eta _{i,j}^{\beta })}}
\end{equation}
где \quad$ \tau _{i,j} - $ расстояние от города i до j;

$\eta _{i,j} - $количество феромонов на ребре ij;

$\alpha - $ параметр влияния длины пути;

$\beta - $ параметр влияния феромона.


3. Обновление феромона \\
Уровень феромона обновляется в соответствии с приведённой формулой:\\
После того, как муравей успешно проходит маршрут, он оставляет на всех пройденных ребрах след, обратно пропорциональный длине пройденного пути. Итого, новый след феромона вычисляется по формуле \ref{form:eva}:
\begin{equation}\label{form:eva} 
	\tau _{i,j}=(1-\rho )\tau _{i,j}+\Delta \tau _{i,j},
\end{equation}
где \quad$ \rho _{i,j}$ - \text{доля феромона, который испарится;} 

$\tau _{i,j}$ - \text{количество феромона на дуге ij;} 

$\Delta \tau _{i,j}$ - \text{количество отложенного феромона, вычисляется по формуле \ref{form:add1}.}

4. Дополнительные действия 

Обычно здесь используется алгоритм локального поиска, однако    он может также появиться и после поиска всех решений. 

\section{Муравьиный алгоритм в задаче коммивояжера}
Рассмотрим, как реализовать четыре составляющие самоорганизации муравьев при оптимизации маршрута коммивояжера. Многократность взаимодействия реализуется итерационным поиском маршрута коммивояжера одновременно несколькими муравьями. При этом каждый муравей рассматривается как отдельный, независимыйкоммивояжер, решающий свою задачу. За однуитерацию алгоритма каждый муравей совершаетполный маршрут коммивояжера.Положительная обратная связь реализуется как имитация поведения муравьев типа «оставление следов – перемещение по следам». Чем больше следов оставлено на тропе — ребре графа в задаче коммивояжера, тем больше муравьев будет передвигаться по ней. При этом на тропе появляются новые следы, привлекающие дополнительных муравьев. Для задачи коммивояжера положительная обратная связь реализуется следующим стохастическим правилом: вероятность включения ребра графа в маршрут муравья пропорциональна количеству феромона на нем.

Теперь с учетом особенностей задачи коммивояжёра, мы можем описать локальные правила поведения муравьев при выборе пути.\

1. Муравьи имеют собственную «память». Поскольку каждый город может быть посещён только один раз, то у каждого муравья есть список уже посещенных городов - список запретов. Обозначим через $J$ список городов, которые необходимо посетить муравью $k$ , находящемуся в городе $i$ . 

2. Муравьи обладают «зрением» - видимость есть эвристическое желание посетить город $j$ , если муравей находится в городе $i$ . Будем считать, что видимость обратно пропорциональна расстоянию между городами. 

3. Муравьи обладают «обонянием» - они могут улавливать след феромона, подтверждающий желание посетить город $j$ из города $i$ на основании опыта других муравьёв. Количество феромона на ребре $(i,j)$ в момент времени $t$ обозначим через  $tau _{i,j} (t)$ 

4. На этом основании мы можем сформулировать вероятностнопропорциональное правило, определяющее вероятность перехода $k$-ого муравья из города $i$  в город $j$. 

5. Пройдя ребро $(i,j)$ , муравей откладывает на нём некоторое количество феромона, которое должно быть связано с оптимальностью сделанного выбора. Пусть $T _{k} (t)$ есть маршрут, пройденный муравьем $k$ к моменту времени $t$ , $L _{k} (t)$ - длина этого маршрута, а $Q$ - параметр, имеющий значение порядка длины оптимального пути. Тогда откладываемое количество феромона может быть задано в виде:

\begin{equation}\label{form:add} 
	{\displaystyle \Delta \tau _{i,j}^k={\begin{cases}Q/L_{k}& {\mbox{Если k-ый мурваей прошел по ребру ij;}}\\0&{\mbox{Иначе}}\end{cases}}}
\end{equation}
где \quad Q - количество феромона, переносимого муравьем;

Тогда
\begin{equation}\label{form:add1} 
	\Delta \tau _{i,j}= \tau _{i,j}^0 + \tau _{i,j}^1 + ... + \tau _{i,j}^k 
\end{equation}

где k - количество муравьев в вершине графа с индексами i и j.


\section*{Вывод}
\addcontentsline{toc}{section}{Введение}
В данном разделе были рассмотрены общие принципы муравьиного алгоритма и применение его к задаче коммивояжера. 


\chapter{Конструкторская часть}
В данном разделе будут рассмотрены основные требования к программе и схемы алгоритмов.

\section{Требования к программе}
\textbf{Требования к вводу:}
у ориентированного графа должно быть хотя бы 2 вершины.
\newline
\textbf{Требования к программе:}
\begin{itemize}
	\item алгоритм полного перебора должен возвращать кратчайший путь в графе.
\end{itemize}
.  
\newline  
\textbf{Входные данные} - матрица смежности графа.  
\newline
\textbf{Выходные данные} - самый короткий/выгодный путь.

\section{Схемы алгоритмов}
На рисунке 2.1 и 2.2 приведены схемы алгоритмов решения задачи коммивояжера.\\
\par
\begin{figure}[h]
	\center{\includegraphics[scale = 0.5]{perebor.png}}
	\caption{Схема алгоритма полного перебора}
	\label{fig:f_p}
\end{figure}
\par
\begin{figure}[h]
	\center{\includegraphics[scale = 0.45]{ants.jpg}}
	\caption{Схема муравьиного агоритма}
	\label{fig:ant}
\end{figure}

\newpage
\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
В данном разделе были рассмотрены требования к программе и схемы алгоритмов.




\chapter{Технологическая часть}
Замеры времени были произведены на: Intel(R) Core(TM) i7-10510U, 4 ядра, 8 логических процессоров.


\section{Выбор ЯП}
В качестве языка программирования был выбран Python. Среда разработки - Pycharm.
Время работы алгоритмов было замерено с помощью класса time. 


\section{Листинг кода алгоритмов}
В этой части будут рассмотрены листинги кода (листинг 3.1 - 3.2) реализованых алгоритмов.
\begin{lstlisting}[label=some-code,caption=Алгоритм поиска полным перебором]
	def perebor_matr():
		len_min = -1
		c = []
		res = []
		n = len(distances)
		
		for i in range(n):
			c.append(i)
			res.append(0)
		
		for k in range(n):
			len1 = 0
			for i in range(n - 1):
				len1 += distances[c[i]][c[i + 1]]
		
			len1 += distances[c[n - 1]][c[0]]
			if len1 < len_min or len_min < 0:
				len_min = len1
				for i in range(n):
					res[i] = c[i]
		return res
	
\end{lstlisting}

\begin{lstlisting}[label=some-code,caption=Муравьиный алгоритм]
	def __init__(self, distances, n_ants, n_best, n_iterations, decay, alpha=1, beta=1):
		self.distances  = distances
		self.pheromone = np.ones(self.distances.shape) / len(distances) 	
		self.all_inds = range(len(distances))
		self.n_ants = n_ants
		self.n_best = n_best
		self.n_iterations = n_iterations
		self.decay = decay
		self.alpha = alpha
		self.beta = beta
	
	def run(self):
		shortest_path = None
		all_time_shortest_path = ("placeholder", np.inf)
		for i in range(self.n_iterations):
		all_paths = self.gen_all_paths()
		self.spread_pheronome(all_paths, self.n_best, shortest_path=shortest_path)
		shortest_path = min(all_paths, key=lambda x: x[1])
		print (shortest_path)
		if shortest_path[1] < all_time_shortest_path[1]:
		all_time_shortest_path = shortest_path            
		self.pheromone * self.decay            
		return all_time_shortest_path
	
	def spread_pheronome(self, all_paths, n_best, shortest_path):
		sorted_paths = sorted(all_paths, key=lambda x: x[1])
		for path, dist in sorted_paths[:n_best]:
		for move in path:
		self.pheromone[move] += 1.0 / self.distances[move]
	
	def gen_path_dist(self, path):
		total_dist = 0
		for ele in path:
		total_dist += self.distances[ele]
		return total_dist
	
	def gen_all_paths(self):
		all_paths = []
		for i in range(self.n_ants):
		path = self.gen_path(0)
		all_paths.append((path, self.gen_path_dist(path)))
		return all_paths
	
	def gen_path(self, start):
		path = []
		visited = set()
		visited.add(start)
		prev = start
		for i in range(len(self.distances) - 1):
		move = self.pick_move(self.pheromone[prev], self.distances[prev], visited)
		path.append((prev, move))
		prev = move
		visited.add(move)
		path.append((prev, start)) # going back to where we started    
		return path
	
	def pick_move(self, pheromone, dist, visited):
		pheromone = np.copy(pheromone)
		pheromone[list(visited)] = 0
		
		row = pheromone ** self.alpha * (( 1.0 / dist) ** self.beta)
		
		norm_row = row / row.sum()
		move = np_choice(self.all_inds, 1, p=norm_row)[0]
		return move
\end{lstlisting}

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
В данном разделе были рассмотрены основные сведения о модулях программы и листинг кода алгоритмов.




\chapter{Исследовательская часть}
В даннном разделе будет проведен сравнительный временной анализ алгоритмов.

\section{Сравнительный анализ на основе замеров времени}
Был проведен замер времени работы алгоритмов при разных размерах графа. На рис.4.1 и рис.4.2 показаны результаты замеров времени.


\begin{tikzpicture}
	\begin{axis}[
		axis lines = left,
		xlabel = {Количество вершин},
		ylabel = {Время (тики)},
		legend pos=north west,
		ymajorgrids=true
		]
		
		
		\addplot[color=blue] table[x index=0, y index= 1] {pereb.txt}; 
		\addlegendentry{Полный перебор}
		
		\addplot[color=orange] table[x index=0, y index= 1] {ants.txt}; 
		\addlegendentry{Муравьиный алгоритм}
		
		
	\end{axis}
\end{tikzpicture}
\begin{center}
	Pис. 4.1: Сравнение времени работы алгоритмов при увеличении размера графа.
\end{center}

\begin{tikzpicture}
	\begin{axis}[
		axis lines = left,
		xlabel = {Количество вершин},
		ylabel = {Время (тики)},
		legend pos=north west,
		ymajorgrids=true
		]
		
		
		\addplot[color=blue] table[x index=0, y index= 1] {pereb2.txt}; 
		\addlegendentry{Полный перебор}
		
		\addplot[color=orange] table[x index=0, y index= 1] {ants.txt}; 
		\addlegendentry{Муравьиный алгоритм}
		
		
	\end{axis}
\end{tikzpicture}
\begin{center}
	Pис. 4.2: Сравнение времени работы алгоритмов на малых размерах графа.
\end{center}

На рисунках 4.1 и 4.2 видно, что муравьиный алгоритм значительно выигрыает по скорости полному перебору при размере графа больше 9.
До 8 вершины алгоритм полного перебора работает быстрее, с максимальным выигрышем по времени в 2,5 раза, при 6 вершинах.
На графе размера 10 полный перебор работает в 30 раз медленнее. 

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
Сравнительный анализ по времени показал, что на больших размерностях (размер графа больше 9) полный перебор крайне медленен относительно муравьиного алгоритма.



\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
В ходе лабораторной работы я изучила возможности применения и реализовала алгоритм полного перебора и муравьиный алгоритм. 

Временной анализ показал, что неэффективно использовать полный перебор на графе размера больше 10.

\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{3}
	\bibitem{diskr} Белоусов А.И., Ткачев С.Б(2006). Дискретная математика, 4-е издание.
	\bibitem{commi2} Т.М. Товстик, Е.В. Жукова - Алгоритм приближенного решения задачи коммивояжера.
	\bibitem{commi} Задача коммивояжера[Электронный ресурс] - режим доступа http://mech.math.msu.su/~shvetz/54/inf/perl-problems/chCommisVoyageur.xhtml
	\item Python [Электронный ресурс]. – Режим доступа:
	https://www.python.org.
	\item PyCharm [Электронный ресурс]. – Режим доступа:
	https://www.jetbrains.com/ru-ru/pycharm.
	\bibitem{ant1} Муравьиные алгоритмы[Электронный ресурс] - режим доступа http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D1%83%D1%80%D0%B0%D0%B2%D1%8C%D0%B8%D0%BD%D1%8B%D0%B5_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B
	\bibitem{shtovba} Штовба С.Д. - Муравьиные алгоритмы.
	\bibitem{Beloysov} И. В. Белоусов(2006), Матрицы и определители, учебное пособие по линейной алгебре, с. 1 - 16
\end{thebibliography}


\end{document}